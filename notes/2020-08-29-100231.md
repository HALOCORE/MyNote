# 【Paper】FlashMeta: A Framework for Inductive Program Synthesis

> Program Synthesis / Paper / PL / PBE / Programming-by-examples

- Programming-by-examples (Inductive Synthesis)
  - search-based synthesis
- Many PBE algorithms -> 
  - one generic meta-algorithm
  - the domain-specific properties of the operators in underlying DSL
- meta-algorithm 
  - propagates example-based constraints on an expression to its subexpressions, leveraging **associated witness functions**
  - witness functions:
    - inverse semantics of the underlying operator.
  - program synthesis methodology
    - **data-driven domain-specific deduction** (D4)
- FlashMeta:
  - generate an efficient synthesizer from the mere DSL definition
- Program Synthesis: a hard combinatorial search problem
  - because of the huge and arbitrary nature of the underlying state space of possible programs.
  - historically 3 ways:
    - **deductive synthesis:**
      - from **declarative and complete** logical specifications
      - success: well-defined application domains, such as numeric computations.
      - advantage: performance
      - disadvantage: manual effort:
        - axiomatize the application domain into a sound and complete system of deductive rules
        - difficult to write logical specifications
    - **Syntax-guided synthesis (SyGuS)**
      - parameterizes generic synthesis algorithms with DSL
      - requires a specification for behavior of programs
      - search over DSL (narrow down the space)
        - expressible in DSL
        - template from user
      - drawback:
        - cannot leverage any domain-specific insights for improving the performance
        - restricts the language of specifications to those expressible in some SMT theory
      - example:
        - CSS selectors (encoding semantics of DOM nodes, CSS, etc.)
    - **Domain-specific Inductive Synthesis**
      - specification in examples
      - examples:
        - FlashFill in Excel
        - FlashExtract in PowerShell
        - [Trifacta’s textual data transformation toolkit](http://www.trifacta.com/)
      - limitations (synthesizer):
        - developing the synthesis algorithm requires deep domain-specific insights
        - implementation: time-consuming
        - DSL hard to extend (small change in DSL -> More change in algorithm)
- This paper: Data-Driven Domain-Specific Deduction (D4)
  - unifies the strengths of deductive, syntax-guided, and domain-specific inductive approaches in one meta-algorithm.
- How this paper handle program synthesis problem — **3 dimensions**
  - intent specification
    - inductively (I/O examples)
    - We generalize it to properties of the output on specific input states? in order to enable effortless intent specification in complex scenarios
  - program space
    - syntax guided
    - our methodology also permits arbitrarily complex functional DSLs with rich domain-specific semantics, and enables scalable program synthesis for such DSLs
  - search strategy
    - based on deduction
    - based on witness functions, which propagate example-based specifications on a DSL operator down into specifications on the operator parameters
    - combine this **deductive inference** with **enumerative search**, a complementary **state-of-the-art approach** to program synthesis
    - deductive inference is performed using the standard algorithmic principle of **divide-and conquer**.
- **The key observation** that makes D4 scalable and usable is that many reduction logics for deducing specifications for simpler sub-problems depends only on the behavior of the involved operator on the concrete values in the original specification.
  - enable modularity (reduction logic depends only on the operator behavior)
  - domain expert can do that, no need for proficiency in program synthesis

- D4 as a Unification of Prior Work
- 